#include <vector.h>

/**********基于32M晶振**********/

/*****************************************
 *定时器1初始化函数
 *例:timer1_init(1000); 定时1000us 
 *****************************************/
void timer1_init(uint time_us)
{
	uint time_mod;

	if(time_us <= 24576)	                          //判断是否超过定时器能够设定的最大值
	{
		time_mod = 65536 - (time_us * 32 / 12);		  //计算定时器需要装入的数值
		TH1 = time_mod >> 8;						  //高位数据写入
		TL1 = time_mod;								  //地位数据写入 相当于 TH1 = time_mod % 256
	}
	else
	{
		TH1 = 0;									  //否则按最小值装入
		TL1 = 0;
	}

    TMOD = 0x10;									  //定时器1工作于十六位定时器模式
	ET1 = 1;										  //使能定时器1
	TR1 = 1;										  //开始计时
	EA  = 1;										  //开全局中断
}

/*****************************************
 *中断函数内部更新定时器赋值函数 
 *例:timer1_update(1000); 重装定时器初值为1000us 
 *****************************************/
void timer1_update(uint time_us)
{
	uint time_mod;

	if(time_us <= 24576)							  //判断是否超过定时器能够设定的最大值
	{												  
		time_mod = 65536 - (time_us * 32 / 12);		  //计算定时器需要装入的数值
		TH1 = time_mod >> 8;						  //高位数据写入
		TL1 = time_mod;								  //地位数据写入 相当于 TH1 = time_mod % 256
	}												  
	else											  
	{												  
		TH1 = 0;									  //否则按最小值装入
		TL1 = 0;
	}
}

/*****************************************
 *定时器0初始化函数
 *例:timer0_init(1000); 定时1000us 
 *****************************************/
void timer0_init(uint time_us)
{
	uint time_mod;

	if(time_us <= 24576)							  //判断是否超过定时器能够设定的最大值
	{												  
		time_mod = 65536 - (time_us * 32 / 12);		  //计算定时器需要装入的数值
		TH0 = time_mod >> 8;						  //高位数据写入
		TL0 = time_mod;								  //地位数据写入 相当于 TH1 = time_mod % 256
	}												  
	else											  
	{												  
		TH0 = 0;									  //否则按最小值装入
		TL0 = 0;									  
	}												  
													  
    TMOD = 0x01;									  //定时器0工作于十六位定时器模式
	ET0 = 1;										  //使能定时器1
	TR0 = 1;										  //开始计时
	EA  = 1;										  //开全局中断
}

/*****************************************
 *中断函数内部更新定时器赋值函数 
 *例:timer0_update(1000); 重装定时器初值为1000us 
 *****************************************/
void timer0_update(uint time_us)
{
	uint time_mod;

	if(time_us <= 24576)							  //判断是否超过定时器能够设定的最大值
	{												  
		time_mod = 65536 - (time_us * 32 / 12);		  //计算定时器需要装入的数值
		TH0 = time_mod >> 8;						  //高位数据写入
		TL0 = time_mod;								  //地位数据写入 相当于 TH1 = time_mod % 256
	}												  
	else											  
	{												  
		TH0 = 0;									  //否则按最小值装入
		TL0 = 0;									  
	}												  
}	

/**********基于11M晶振**********/

/*****************************************
 *定时器1初始化函数
 *例:timer1_init11(1000); 定时1000us 
 *****************************************/
void timer1_init11(uint time_us)
{
	uint time_mod;

	if(time_us <= 24576)	                          //判断是否超过定时器能够设定的最大值
	{
		time_mod = 65536 - (time_us * 11 / 12);		  //计算定时器需要装入的数值
		TH1 = time_mod >> 8;						  //高位数据写入
		TL1 = time_mod;								  //地位数据写入 相当于 TH1 = time_mod % 256
	}
	else
	{
		TH1 = 0;									  //否则按最小值装入
		TL1 = 0;
	}

    TMOD = 0x10;									  //定时器1工作于十六位定时器模式
	ET1 = 1;										  //使能定时器1
	TR1 = 1;										  //开始计时
	EA  = 1;										  //开全局中断
}

/*****************************************
 *中断函数内部更新定时器赋值函数 
 *例:timer1_update11(1000); 重装定时器初值为1000us 
 *****************************************/
void timer1_update11(uint time_us)
{
	uint time_mod;

	if(time_us <= 24576)							  //判断是否超过定时器能够设定的最大值
	{												  
		time_mod = 65536 - (time_us * 11 / 12);		  //计算定时器需要装入的数值
		TH1 = time_mod >> 8;						  //高位数据写入
		TL1 = time_mod;								  //地位数据写入 相当于 TH1 = time_mod % 256
	}												  
	else											  
	{												  
		TH1 = 0;									  //否则按最小值装入
		TL1 = 0;
	}
}

/*****************************************
 *定时器0初始化函数
 *例:timer0_init(1000); 定时1000us 
 *****************************************/
void timer0_init11(uint time_us)
{
	uint time_mod;

	if(time_us <= 24576)							  //判断是否超过定时器能够设定的最大值
	{												  
		time_mod = 65536 - (time_us * 11 / 12);		  //计算定时器需要装入的数值
		TH0 = time_mod >> 8;						  //高位数据写入
		TL0 = time_mod;								  //地位数据写入 相当于 TH1 = time_mod % 256
	}												  
	else											  
	{												  
		TH0 = 0;									  //否则按最小值装入
		TL0 = 0;									  
	}												  
													  
    TMOD = 0x01;									  //定时器0工作于十六位定时器模式
	ET0 = 1;										  //使能定时器1
	TR0 = 1;										  //开始计时
	EA  = 1;										  //开全局中断
}

/*****************************************
 *中断函数内部更新定时器赋值函数 
 *例:timer0_update(1000); 重装定时器初值为1000us 
 *****************************************/
void timer0_update11(uint time_us)
{
	uint time_mod;

	if(time_us <= 24576)							  //判断是否超过定时器能够设定的最大值
	{												  
		time_mod = 65536 - (time_us * 11 / 12);		  //计算定时器需要装入的数值
		TH0 = time_mod >> 8;						  //高位数据写入
		TL0 = time_mod;								  //地位数据写入 相当于 TH1 = time_mod % 256
	}												  
	else											  
	{												  
		TH0 = 0;									  //否则按最小值装入
		TL0 = 0;									  
	}												  
}	
