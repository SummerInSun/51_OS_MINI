C51 COMPILER V9.02   CORE                                                                  03/06/2016 13:46:23 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE CORE
OBJECT MODULE PLACED IN .\core.obj
COMPILER INVOKED BY: D:\msprograms\keil4\C51\BIN\C51.EXE ..\src\core.c OPTIMIZE(2,SPEED) BROWSE INCDIR(../head) DEBUG OB
                    -JECTEXTEND PRINT(.\core.lst) OBJECT(.\core.obj)

line level    source

   1          #include "core.h"
   2          
   3          /* 申请任务控制模块结构体数组，存储所有任务的控制结构体 */
   4          xdata struct task_pcb task_pcb_buf[TASK_MAX];
   5          /* 任务堆栈数组 */
   6          static unsigned char idata task_sp[TASK_MAX][SP_DEEP];
   7          /* 正在运行任务的id，初始化为0，默认最开始运行0号任务 */
   8          xdata unsigned char current_id = 0;
   9          /* 任务运行标志，值反映了有多少任务正在运行 */
  10          xdata unsigned long task_run_flag = 0;
  11          /* 从开机到现在任务运行时间，单位10ms */
  12          xdata unsigned long task_runtime = 0;
  13          /* 设置系统运行标志，1为正在运行，0为未开始运行。初始化为0 */
  14          bit task_start_flag = 0;
  15          
  16          
  17          //void pop_ptr(void)
  18          //{
  19          //      #pragma asm
  20          //              POP 7
  21          //              POP 6
  22          //              POP 5
  23          //              POP 4
  24          //              POP 3
  25          //              POP 2
  26          //              POP 1
  27          //              POP 0
  28          //              POP PSW
  29          //              POP DPH
  30          //              POP DPL
  31          //              POP B
  32          //              POP ACC
  33          //      #pragma endasm
  34          //}
  35          
  36          
  37          /* 系统开机初始化 */
  38          void OS_init(void)
  39          {
  40   1              current_id = 0;                 //当前运行任务号为0
  41   1              task_run_flag = 0;              //当前无任务运行
  42   1              task_runtime = 0;               //当前运行时间为0
  43   1              task_start_flag = 0;    //系统未开始运行        
  44   1      }
  45          
  46          /* 系统开始任务调度 */
  47          void OS_start(void)
  48          {
  49   1              task_pcb_buf[current_id].sp -= NUM_PTR_NOPC;
  50   1      
  51   1              SP = task_pcb_buf[current_id].sp;
  52   1              TR1 = 1;                                                                                  //开始计时
  53   1              ET1 = 1;                                                                                  //使能定时器1
  54   1              EA  = 1;                                                                                  //开全局中断
C51 COMPILER V9.02   CORE                                                                  03/06/2016 13:46:23 PAGE 2   

  55   1      }
  56          
  57          /* 任务切换，用在定时器里面进行任务的切换 */
  58          void task_switch(void)
  59          {
  60   1              EA= 0;  //任务切换的时候不允许被中断
  61   1              /* 保存寄存器值，寄存器值入栈 */
  62   1      //      push_ptr();
  63   1              /* 把转换之前任务的栈指针保存在数组里面 */
  64   1              task_pcb_buf[current_id].sp = SP;
  65   1      //      if(tasks_list
  66   1      
  67   1              /* 寄存器值出栈，恢复寄存器值 */
  68   1      //      pop_ptr();
  69   1              EA = 1; //任务切换完成，重新开启中断
  70   1      }
  71          
  72          /* 创建任务 
  73           * priority 任务优先级
  74           * task_address 任务地址
  75           * task_msg 任务消息指针
  76           */
  77          void task_create(unsigned char priority, unsigned int task_address, unsigned char task_msg)
  78          {
  79   1              static unsigned char i = 0;
  80   1              static unsigned char stack_deep = 0;
  81   1              static unsigned char stack_p;
  82   1      
  83   1              for(i = 0; i < TASK_MAX; i ++)
  84   1              {
  85   2                      if(task_run_flag & (1 << i))
  86   2                              ;
  87   2                      else
  88   2                      {
  89   3                              stack_p = (unsigned char)task_sp[i];    //把堆栈指针的地址赋值堆栈地址暂存区
  90   3                              /* 初始化清空堆栈区 */
  91   3                              for(stack_deep = 0; stack_deep < SP_DEEP; stack_deep ++)
  92   3                                      ((unsigned char idata *)stack_p)[stack_deep] = 0;
  93   3                              
  94   3                              task_pcb_buf[i].sp = stack_p;   //把堆栈指针赋值给任务结构体
  95   3                              ((unsigned char idata *)stack_p)[0] = task_address % 256;         //把任务地址低8位入栈
  96   3                              task_pcb_buf[i].sp ++;
  97   3                              ((unsigned char idata *)stack_p)[1] = task_address >> 8;          //把任务地址高8位入栈
  98   3                              task_pcb_buf[i].sp += NUM_PTR_NOPC;             //将任务堆栈指针值设为任务切换时的状态
  99   3                              
 100   3                              task_run_flag |= (1 << i);              //把此位设置为有任务
 101   3                              
 102   3                              return; //任务创建成功，返回
 103   3                      }
 104   2              }
 105   1      }
*** WARNING C280 IN LINE 77 OF ..\SRC\CORE.C: 'priority': unreferenced local variable
*** WARNING C280 IN LINE 77 OF ..\SRC\CORE.C: 'task_msg': unreferenced local variable
 106          
 107          
 108          /* 中断服务函数，用定时器1进行任务调度 */
 109          void timer1_task_switch(void) interrupt 3
 110          {
 111   1              unsigned char temp = 0;
 112   1              
 113   1              EA = 0; //任务切换的时候要关闭中断
 114   1      
C51 COMPILER V9.02   CORE                                                                  03/06/2016 13:46:23 PAGE 3   

 115   1      //      if(!task_start_flag)    //第一次进入中断
 116   1      //      {
 117   1      //              SP = SP - NUM_PTR_NOPC; //此时指针指向调用此中断时候压入的PC低地址
 118   1      //              for(temp = 1; temp < NUM_PTR_NOPC + 1; temp ++)
 119   1      //              {
 120   1      //                      ((unsigned char idata *)SP)[temp] = ((unsigned char idata *)SP)[temp + 2];      //将除了PC之外的寄存器值往
             -下平移两位
 121   1      //              }
 122   1      //              SP = SP + NUM_PTR_NOPC;
 123   1      //              task_start_flag = 1; //设置系统运行标志，此时为已经运行
 124   1      //      }
 125   1      
 126   1              /* 保存寄存器值，寄存器值入栈 */
 127   1      //      push_ptr();      /* 在现有编译环境下寄存器已经由系统自动保存了 */
 128   1              
 129   1              TF1 = 0;        //清除中断标志
 130   1              
 131   1              /* 把转换之前任务的栈指针保存在其任务结构体里面 */
 132   1              task_pcb_buf[current_id].sp = SP;
 133   1      
 134   1              /* 第一版，任务轮流被调用，查找本次任务之后的任务，有的话直接跳到 T2_switch_exit 处执行*/
 135   1              for(temp = current_id + 1; temp < TASK_MAX; temp ++)
 136   1              {
 137   2                      if(task_run_flag & (1 << temp))
 138   2                      {
 139   3                              current_id = temp;
 140   3                              goto T2_switch_exit;                    
 141   3                      }
 142   2              }
 143   1      
 144   1              /* 没有找到正在运行任务之后的任务，返回前面进行查找 */
 145   1              for(temp = 0; temp < current_id + 1; temp ++)
 146   1              {
 147   2                      if(task_run_flag & (1 << temp))
 148   2                      {
 149   3                              current_id = temp;
 150   3                              goto T2_switch_exit;    
 151   3                      }
 152   2                      else
 153   2                              goto T2_switch_exit;
 154   2              }
 155   1      
 156   1      T2_switch_exit:
 157   1              SP = task_pcb_buf[current_id].sp;       //把要运行的任务SP地址传入SP寄存器
 158   1      
 159   1              task_runtime ++;        //系统运行时间加1
 160   1              /* 寄存器值出栈，恢复寄存器值 */
 161   1      //      pop_ptr();
 162   1              EA = 1; //任务切换完成，重新开启中断
 163   1      }
 164          
 165          /* 堆栈的测试 */
 166          void sp_test(void)
 167          {
 168   1              SP = task_sp;
 169   1      
 170   1      }
 171          //      #pragma asm
 172          //              PUSH DPL
 173          //              PUSH DPH
 174          //      #pragma endasm
 175          
C51 COMPILER V9.02   CORE                                                                  03/06/2016 13:46:23 PAGE 4   

 176          //      void push_ptr(void)
 177          //{
 178          //      #pragma asm
 179          //              PUSH ACC
 180          //              PUSH B
 181          //              PUSH DPL
 182          //              PUSH DPH
 183          //              PUSH PSW
 184          //              PUSH 0
 185          //              PUSH 1
 186          //              PUSH 2
 187          //              PUSH 3
 188          //              PUSH 4
 189          //              PUSH 5
 190          //              PUSH 6
 191          //              PUSH 7
 192          //      #pragma endasm
 193          //}
 194          //
 195          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    744    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     54    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       5
   IDATA SIZE       =    135    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
