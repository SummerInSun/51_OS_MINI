C51 COMPILER V9.02   CORE                                                                  03/26/2016 11:01:22 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE CORE
OBJECT MODULE PLACED IN .\core.obj
COMPILER INVOKED BY: D:\msprograms\keil4\C51\BIN\C51.EXE ..\src\core.c OPTIMIZE(2,SPEED) BROWSE INCDIR(../head;../board/
                    -head) DEBUG OBJECTEXTEND PRINT(.\core.lst) OBJECT(.\core.obj)

line level    source

   1          #include "core.h"
   2          
   3          /* ÉêÇëÈÎÎñ¿ØÖÆÄ£¿é½á¹¹ÌåÊı×é£¬´æ´¢ËùÓĞÈÎÎñµÄ¿ØÖÆ½á¹¹Ìå */
   4          struct task_pcb xdata task_pcb_buf[TASK_MAX];
   5          
   6          #ifdef XDATA_SP_BUFFER
              /* ÈÎÎñ¶ÑÕ»Êı×é£¨Î±¶ÑÕ»£¬Êµ¼Ê¶ÑÕ»Ö»ÄÜ·ÅÔÚidataÀïÃæ£© */
              volatile unsigned char xdata task_sp[TASK_MAX][SP_DEEP];
              /* ÈÎÎñ¶ÑÕ»¿Õ¼ä£¬ËùÓĞÈÎÎñ¹²ÓÃÍ¬Ò»¸ö¶ÑÕ»¿Õ¼ä */
              volatile unsigned char idata task_sp_public[PUBLIC_SP_DEEP];
              unsigned char idata task_sp_bottom;     //Õ»¿Õ¼äµÄµ×²¿
              #endif
  13          #ifdef IDATA_SP_BUFFER
  14          /* ÈÎÎñ¶ÑÕ»Êı×é */
  15          volatile unsigned char idata task_sp[TASK_MAX][SP_DEEP];
  16          #endif
  17          
  18          /* µ±Ç°ÏµÍ³ÕıÔÚÔËĞĞµÄÈÎÎñÊı */
  19          xdata unsigned char task_running = 0;
  20          /* ÕıÔÚÔËĞĞÈÎÎñµÄid£¬³õÊ¼»¯Îª0£¬Ä¬ÈÏ×î¿ªÊ¼ÔËĞĞ0ºÅÈÎÎñ */
  21          xdata unsigned char current_id = 0;
  22          /* ÈÎÎñÔËĞĞ±êÖ¾£¬Öµ·´Ó³ÁËÓĞ¶àÉÙÈÎÎñÕıÔÚÔËĞĞ */
  23          xdata unsigned long task_run_flag = 0;
  24          /* Í³¼Æ½øÈëÁÙ½çÕ»µÄ´ÎÊı */
  25          xdata unsigned int critical_counter = 0;
  26          /* ´Ó¿ª»úµ½ÏÖÔÚÈÎÎñÔËĞĞÊ±¼ä£¬µ¥Î»10ms */
  27          xdata unsigned long task_runtime = 0;
  28          /* ´®¿Ú½ÓÊÕÊı¾İ»º³åÇø£¬³¤¶ÈÎª256¸ö×Ö½Ú */
  29          xdata unsigned char reve_buff[256];
  30          xdata unsigned char cmd_split[10][20];
  31          /* ÉèÖÃÏµÍ³ÔËĞĞ±êÖ¾£¬1ÎªÕıÔÚÔËĞĞ£¬0ÎªÎ´¿ªÊ¼ÔËĞĞ¡£³õÊ¼»¯Îª0 */
  32          bit task_start_flag = 0;
  33          
  34          //void pop_ptr(void)
  35          //{
  36          //      #pragma asm
  37          //              POP 7
  38          //              POP 6
  39          //              POP 5
  40          //              POP 4
  41          //              POP 3
  42          //              POP 2
  43          //              POP 1
  44          //              POP 0
  45          //              POP PSW
  46          //              POP DPH
  47          //              POP DPL
  48          //              POP B
  49          //              POP ACC
  50          //      #pragma endasm
  51          //}
  52          
  53          /* ÏµÍ³ÑÓÊ±,µ¥Î»ms */
  54          void OS_delay(unsigned int ms)
C51 COMPILER V9.02   CORE                                                                  03/26/2016 11:01:22 PAGE 2   

  55          {
  56   1              ms = ms / 10;   
  57   1              task_delay(ms);
  58   1      
  59   1              while(task_pcb_buf[current_id].delay);
  60   1      }
  61          
  62          /* ÏµÍ³¿ª»ú³õÊ¼»¯ */
  63          void OS_init(void)
  64          {
  65   1              unsigned int i = 0;
  66   1      
  67   1              current_id = 0;                 //µ±Ç°ÔËĞĞÈÎÎñºÅÎª0
  68   1              task_run_flag = 0;              //µ±Ç°ÎŞÈÎÎñÔËĞĞ
  69   1              task_runtime = 0;               //µ±Ç°ÔËĞĞÊ±¼äÎª0
  70   1              task_start_flag = 0;    //ÏµÍ³Î´¿ªÊ¼ÔËĞĞ
  71   1              
  72   1              /* ÈÎÎñÔËĞĞÊ±¼äÈ«²¿ÇåÁã */
  73   1              for(i = 0; i < TASK_MAX; i ++)
  74   1              {
  75   2                      task_pcb_buf[i].run_time = 0;
  76   2                      task_pcb_buf[i].delay  = 0;
  77   2              }       
  78   1      }
  79          
  80          /* ÏµÍ³¿ªÊ¼ÈÎÎñµ÷¶È */
  81          void OS_start(void)
  82          {
  83   1      #ifdef XDATA_SP_BUFFER
                      task_sp_bottom = task_sp_public;        //½«³ÌĞòÊµ¼ÊÔËĞĞµÄÕ»¿Õ¼äÆğÊ¼µØÖ·´«¸øÕ»µ×Ôİ´æ±äÁ¿
              
                      task_sp_public[0] = task_sp[current_id][0];      //¿ªÊ¼½øÈëÈÎÎñÇĞ»»ÖĞ¶Ï·şÎñº¯ÊıµÄÊ±ºò°ÑÏÂÒ»²½¸ÃÔËĞĞµÄº¯ÊıµÄµØ
             -Ö·
                      task_sp_public[1] = task_sp[current_id][1];      //¸ß°ËÎ»ÓëµÍ°ËÎ»´æµ½Õ»¿Õ¼äÖĞ
              
                      SP = task_sp_public;    //°ÑÕ»¿Õ¼äÆğÊ¼µØÖ·¸³Öµ¸øSPÖ¸Õë
                      SP = SP + 1;                    //SPÖ¸Õë¼ÓÒ»£¬Ö¸Ïòº¯ÊıµØÖ·µÄ¸ß°ËÎ»£¬¿ªÊ¼ÔËĞĞ£¨51µÄÕ»Éú³¤·½ÏòÊÇ³¯×ÅµØÖ·Ôö¼ÓµÄ·½ÏòÉú³¤µÄ£
             -©
                      TR1 = 1;                                                                                  //¿ªÊ¼¼ÆÊ±
                      ET1 = 1;                                                                                  //Ê¹ÄÜ¶¨Ê±Æ÷1
                      EA  = 1;                                                                                  //¿ªÈ«¾ÖÖĞ¶Ï
              #endif
  95   1      #ifdef IDATA_SP_BUFFER
  96   1              task_pcb_buf[current_id].sp -= NUM_PTR_NOPC;
  97   1      
  98   1              SP = task_pcb_buf[current_id].sp;
  99   1              TR1 = 1;                                                                                  //¿ªÊ¼¼ÆÊ±
 100   1              ET1 = 1;                                                                                  //Ê¹ÄÜ¶¨Ê±Æ÷1
 101   1              EA  = 1;                                                                                  //¿ªÈ«¾ÖÖĞ¶Ï
 102   1      #endif
 103   1              
 104   1      }
 105          
 106          /* É±µôÒ»¸öÈÎÎñ */
 107          unsigned char task_kill(unsigned char pid)
 108          {
 109   1              ENTER_CRITICAL;         //½øÈëÁÙ½çÕ»£¬ÒÔÃâÔÚÖ´ĞĞµÄ¹ı³ÌÖĞ±»ÖĞ¶Ï
 110   1              if(task_run_flag & (1 << pid))
 111   1              {
 112   2                      task_run_flag &= ~(1 << pid);   
 113   2      
 114   2              }
C51 COMPILER V9.02   CORE                                                                  03/26/2016 11:01:22 PAGE 3   

 115   1              else
 116   1              {
 117   2                      goto error;
 118   2              }
 119   1              task_running --;        //µ±Ç°ÏµÍ³ÕıÔÚÔËĞĞµÄÈÎÎñÊı¼õ1
 120   1              EXIT_CRITICAL;          //ÍË³öÁÙ½çÕ»£¬ÈÎÎñ¼ÌĞøÔËĞĞ
 121   1              return 0;       
 122   1      error:          
 123   1              EXIT_CRITICAL;          //ÍË³öÁÙ½çÕ»£¬ÈÎÎñ¼ÌĞøÔËĞĞ
 124   1              return 1;
 125   1      }
 126          
 127          /* ÈÎÎñÇĞ»»£¬ÓÃÔÚ¶¨Ê±Æ÷ÀïÃæ½øĞĞÈÎÎñµÄÇĞ»» £¨ÔİÊ±ÆúÓÃ£©*/
 128          void task_switch(void)
 129          {
 130   1              EA= 0;  //ÈÎÎñÇĞ»»µÄÊ±ºò²»ÔÊĞí±»ÖĞ¶Ï
 131   1              /* ±£´æ¼Ä´æÆ÷Öµ£¬¼Ä´æÆ÷ÖµÈëÕ» */
 132   1      //      push_ptr();
 133   1              /* °Ñ×ª»»Ö®Ç°ÈÎÎñµÄÕ»Ö¸Õë±£´æÔÚÊı×éÀïÃæ */
 134   1              task_pcb_buf[current_id].sp = SP;
 135   1      //      if(tasks_list
 136   1      
 137   1              /* ¼Ä´æÆ÷Öµ³öÕ»£¬»Ö¸´¼Ä´æÆ÷Öµ */
 138   1      //      pop_ptr();
 139   1              EA = 1; //ÈÎÎñÇĞ»»Íê³É£¬ÖØĞÂ¿ªÆôÖĞ¶Ï
 140   1      }
 141          
 142          /* ´´½¨ÈÎÎñ 
 143           * priority ÈÎÎñÓÅÏÈ¼¶
 144           * task_address ÈÎÎñµØÖ·
 145           * task_msg ÈÎÎñÏûÏ¢Ö¸Õë
 146           * name ÈÎÎñµÄÃû×Ö
 147           */
 148          unsigned char task_create(unsigned char priority, unsigned int task_address, unsigned char xdata *task_msg
             -, unsigned char *name)
 149          {
 150   1              static xdata unsigned char i = 0;
 151   1              static xdata unsigned char stack_deep = 0;
 152   1              static unsigned char stack_p;
 153   1      
 154   1              ENTER_CRITICAL; //¶¯Ì¬´´½¨ÈÎÎñµÄÊ±ºò²»ÔÊĞí±»ÖĞ¶Ï£¬´ËÊ±Ó¦¸Ã½øÈëÁÙ½çÕ»
 155   1      
 156   1              for(i = 0; i < TASK_MAX; i ++)
 157   1              {
 158   2                      if(task_run_flag & (1 << i))
 159   2                              ;
 160   2                      else
 161   2                      {
 162   3      #ifdef XDATA_SP_BUFFER  //Õ»¿Õ¼äÔÚxdataÇø
                                      /* ³õÊ¼»¯Çå¿Õ¶ÑÕ»Çø */
                                      for(stack_deep = 0; stack_deep < SP_DEEP; stack_deep ++)
                                              task_sp[i][stack_deep] = 0;
                                      
                                      task_pcb_buf[i].sp = 14;        //³õÊ¼»¯Ñ¹ÈëÕ»ÖĞÊı¾İµÄ³¤¶ÈÎª14
                                      task_sp[i][0] = task_address % 256;       //°ÑÈÎÎñµØÖ·µÍ8Î»ÈëÕ»
                                      task_sp[i][1] = task_address >> 8;        //°ÑÈÎÎñµØÖ·¸ß8Î»ÈëÕ»
                                      
                                      task_pcb_buf[i].priority = priority;    //ÉèÖÃÈÎÎñµÄÓÅÏÈ¼¶
                                      task_pcb_buf[i].msg              = task_msg;    //ÉèÖÃÈÎÎñµÄÏûÏ¢Ö¸Õë
                                      task_pcb_buf[i].id       = name;                //ÈÎÎñÃûÖ¸Õë¸³Öµ¸øid³ÉÔ±
                                      
                                      task_run_flag |= (1 << i);              //°Ñ´ËÎ»ÉèÖÃÎªÓĞÈÎÎñ
C51 COMPILER V9.02   CORE                                                                  03/26/2016 11:01:22 PAGE 4   

              #endif
 177   3      #ifdef IDATA_SP_BUFFER  //Õ»¿Õ¼äÔÚidataÇø
 178   3                              stack_p = (unsigned char)task_sp[i];    //°Ñ¶ÑÕ»Ö¸ÕëµÄµØÖ·¸³Öµ¶ÑÕ»µØÖ·Ôİ´æÇø
 179   3                              /* ³õÊ¼»¯Çå¿Õ¶ÑÕ»Çø */
 180   3                              for(stack_deep = 0; stack_deep < SP_DEEP; stack_deep ++)
 181   3                                      ((unsigned char idata *)stack_p)[stack_deep] = 0;
 182   3                              
 183   3                              task_pcb_buf[i].sp = stack_p;   //°Ñ¶ÑÕ»Ö¸Õë¸³Öµ¸øÈÎÎñ½á¹¹Ìå
 184   3                              ((unsigned char idata *)stack_p)[0] = task_address % 256;         //°ÑÈÎÎñµØÖ·µÍ8Î»ÈëÕ»
 185   3                              task_pcb_buf[i].sp ++;
 186   3                              ((unsigned char idata *)stack_p)[1] = task_address >> 8;          //°ÑÈÎÎñµØÖ·¸ß8Î»ÈëÕ»
 187   3                              
 188   3                              task_pcb_buf[i].sp += NUM_PTR_NOPC;             //½«ÈÎÎñ¶ÑÕ»Ö¸ÕëÖµÉèÎªÈÎÎñÇĞ»»Ê±µÄ×´Ì¬
 189   3                              task_pcb_buf[i].priority = priority;    //ÉèÖÃÈÎÎñµÄÓÅÏÈ¼¶
 190   3                              task_pcb_buf[i].msg              = task_msg;    //ÉèÖÃÈÎÎñµÄÏûÏ¢Ö¸Õë
 191   3                              task_pcb_buf[i].id       = name;
 192   3                              
 193   3                              task_run_flag |= (1 << i);              //°Ñ´ËÎ»ÉèÖÃÎªÓĞÈÎÎñ
 194   3      #endif
 195   3                              
 196   3                              task_running ++;        //µ±Ç°ÏµÍ³ÕıÔÚÔËĞĞµÄÈÎÎñÊı¼Ó1
 197   3                              EXIT_CRITICAL;  //ÈÎÎñ´´½¨Íê±Ï£¬ÍË³öÁÙ½çÕ»
 198   3      
 199   3                              return 0;       //ÈÎÎñ´´½¨³É¹¦£¬·µ»Ø
 200   3                      }
 201   2              }
 202   1      
 203   1              EXIT_CRITICAL;          //ÈÎÎñ´´½¨Ê§°Ü£¬Ò²ÒªÍË³öÁÙ½çÕ»
 204   1              return 1;                       //×ÊÔ´²»×ã£¬ÎŞ·¨¼ÌĞø´´½¨ÈÎÎñ£¬·µ»Ø1
 205   1      }
 206          
 207          
 208          /* ÖĞ¶Ï·şÎñº¯Êı£¬ÓÃ¶¨Ê±Æ÷1½øĞĞÈÎÎñµ÷¶È */
 209          void timer1_task_switch(void) interrupt 3
 210          {
 211   1              unsigned char xdata temp = 0;
 212   1              char sp_count = 0;
 213   1              
 214   1              EA = 0; //ÈÎÎñÇĞ»»µÄÊ±ºòÒª¹Ø±ÕÖĞ¶Ï
 215   1      
 216   1      /* ÕâÀïµÄ³ÌĞò²»ÓÃ£¬ÒòÎª±àÒëÆ÷±àÒëÖ®ºóµÄ½á¹ûÊÇ²»ĞèÒªÏÂÃæÕâ¶Î±»×¢ÊÍµÄÓï¾ä */
 217   1      //      if(!task_start_flag)    //µÚÒ»´Î½øÈëÖĞ¶Ï
 218   1      //      {
 219   1      //              SP = SP - NUM_PTR_NOPC; //´ËÊ±Ö¸ÕëÖ¸Ïòµ÷ÓÃ´ËÖĞ¶ÏÊ±ºòÑ¹ÈëµÄPCµÍµØÖ·
 220   1      //              for(temp = 1; temp < NUM_PTR_NOPC + 1; temp ++)
 221   1      //              {
 222   1      //                      ((unsigned char idata *)SP)[temp] = ((unsigned char idata *)SP)[temp + 2];      //½«³ıÁËPCÖ®ÍâµÄ¼Ä´æÆ÷ÖµÍù
             -ÏÂÆ½ÒÆÁ½Î»
 223   1      //              }
 224   1      //              SP = SP + NUM_PTR_NOPC;
 225   1      //              task_start_flag = 1; //ÉèÖÃÏµÍ³ÔËĞĞ±êÖ¾£¬´ËÊ±ÎªÒÑ¾­ÔËĞĞ
 226   1      //      }
 227   1      
 228   1              /* ±£´æ¼Ä´æÆ÷Öµ£¬¼Ä´æÆ÷ÖµÈëÕ» */
 229   1      //      push_ptr();      /* ÔÚÏÖÓĞ±àÒë»·¾³ÏÂ¼Ä´æÆ÷ÒÑ¾­ÓÉÏµÍ³×Ô¶¯±£´æÁË */
 230   1              
 231   1              TF1 = 0;        //Çå³ıÖĞ¶Ï±êÖ¾
 232   1      #ifdef XDATA_SP_BUFFER
                      /* ½«³ÌĞòÊµ¼ÊÔËĞĞµÄÕ»¿Õ¼ä²ÎÊıÖµ´æµ½xdataÇø */
                      for(sp_count = 0; SP >= task_sp_bottom; SP--)
                      {
                              task_sp[current_id][sp_count] = ((unsigned char idata*)task_sp_bottom)[sp_count];
C51 COMPILER V9.02   CORE                                                                  03/26/2016 11:01:22 PAGE 5   

                              sp_count ++;
                      }
                      sp_count --;    //forÑ­»·ÍË³ö¼õÒ»
                      /* °Ñ×ª»»Ö®Ç°ÈÎÎñµÄÕ»Ö¸Õë±£´æÔÚÆäÈÎÎñ½á¹¹ÌåÀïÃæ */
                      task_pcb_buf[current_id].sp = sp_count;
              #endif
 243   1      #ifdef IDATA_SP_BUFFER
 244   1              /* °Ñ×ª»»Ö®Ç°ÈÎÎñµÄÕ»Ö¸Õë±£´æÔÚÆäÈÎÎñ½á¹¹ÌåÀïÃæ */
 245   1              task_pcb_buf[current_id].sp = SP;
 246   1      #endif
 247   1      #if 0   //Ê±¼äÆ¬Æ½¾ù·ÖÅäÂÖ»»·¨£¬ÒÑ¾­±»ÆúÓÃ
                      /* µÚÒ»°æ£¬ÈÎÎñÂÖÁ÷±»µ÷ÓÃ£¬²éÕÒ±¾´ÎÈÎÎñÖ®ºóµÄÈÎÎñ£¬ÓĞµÄ»°Ö±½ÓÌøµ½ T2_switch_exit ´¦Ö´ĞĞ*/
                      for(temp = current_id + 1; temp < TASK_MAX; temp ++)
                      {
                              if(task_run_flag & (1 << temp))
                              {
                                      current_id = temp;
                                      goto T2_switch_exit;                    
                              }
                      }
              
                      /* Ã»ÓĞÕÒµ½ÕıÔÚÔËĞĞÈÎÎñÖ®ºóµÄÈÎÎñ£¬·µ»ØÇ°Ãæ½øĞĞ²éÕÒ */
                      for(temp = 0; temp < current_id + 1; temp ++)
                      {
                              if(task_run_flag & (1 << temp))
                              {
                                      current_id = temp;
                                      goto T2_switch_exit;    
                              }
                              else
                                      goto T2_switch_exit;
                      }
              #endif
 270   1              //½«×îµÍÓÅÏÈ¼¶µÄid¸³Öµ¸øÕıÔÚÔËĞĞµÄidºÅ
 271   1              current_id = 0;
 272   1              //ÈÎÎñidµÄÇĞ»»
 273   1              for(temp = 0; temp < TASK_MAX; temp ++)
 274   1              {
 275   2                      if(task_run_flag & (1 << temp))
 276   2                      {
 277   3                              /* ²éÕÒ¶Ô±ÈÓÅÏÈ¼¶´óĞ¡ */
 278   3                              if(task_pcb_buf[temp].priority < task_pcb_buf[current_id].priority)
 279   3                              {
 280   4                                      if(task_pcb_buf[temp].delay != 0)       //ÈÎÎñÔÚÑÓÊ±£¬²»ÇĞ»»£¬ÈÎÎñÑÓÊ±ÊıÁ¿¼õÒ»
 281   4                                      {
 282   5                                              task_pcb_buf[temp].delay --;                    
 283   5                                      }
 284   4                                      else if(task_pcb_buf[temp].suspend == 1)        //ÈÎÎñ±»¹ÒÆğ£¬²»ÇĞ»»
 285   4                                              continue;
 286   4                                      else
 287   4                                      {
 288   5                                              current_id = temp;              
 289   5                                              task_pcb_buf[current_id].run_time ++;   //ÈÎÎñ¿ÉÒÔÇĞ»»£¬²¢ÇÒ¸ÃÈÎÎñµÄÖ´ĞĞÊ±¼ä¼ÓÒ»£¬ÓÃÀ´Í³¼ÆCPUÊ¹ÓÃÂÊ
 290   5                                      }
 291   4                              }
 292   3                      }
 293   2              }
 294   1              /* Èç¹ûÈÎÎñ0ÓĞÑÓÊ±µÄ»°£¬½«ÈÎÎñ0µÄÑÓÊ±¼õÒ»£¨Ò»°ãÓÃ²»µ½£© */
 295   1              if(task_pcb_buf[0].delay != 0)
 296   1              {
 297   2                      task_pcb_buf[0].delay --;                       
 298   2              }
C51 COMPILER V9.02   CORE                                                                  03/26/2016 11:01:22 PAGE 6   

 299   1              
 300   1      #ifdef XDATA_SP_BUFFER
                      SP ++;  //ÉÏ¸öforÑ­»·³öÀ´µÄÊ±ºòSPµÄÖµ¶à¼õÁËÒ»´Î
                      sp_count = task_pcb_buf[current_id].sp;         //½«ÉÏ´Î¼ÇÂ¼µÄsp_countµÄÖµÔÙ´Î¸³Öµ¸øsp_count
                      /* ½«xdataÇøÓò´æ´¢µÄÕ»²ÎÊıÖØĞÂ¸³Öµ¸øÊµ¼ÊÔËĞĞµÄÕ»¿Õ¼ä */
                      for(; sp_count >= 0; SP++)
                      {
                              ((unsigned char idata*)task_sp_bottom)[sp_count] = task_sp[current_id][sp_count];
                              sp_count --;
                      }
                      SP --;  //forÑ­»·ÍË³öµÄÊ±ºòĞèÒª¼õÈ¥Ò»¸öÊı
                      task_pcb_buf[current_id].new_circle = 1;        //ÈÎÎñÓÖÒ»´Îµ½´ï
              #endif
 312   1      #ifdef IDATA_SP_BUFFER
 313   1              SP = task_pcb_buf[current_id].sp;       //°ÑÒªÔËĞĞµÄÈÎÎñSPµØÖ·´«ÈëSP¼Ä´æÆ÷
 314   1              task_pcb_buf[current_id].new_circle = 1;        //ÈÎÎñÓÖÒ»´Îµ½´ï
 315   1      #endif
 316   1              task_runtime ++;        //ÏµÍ³ÔËĞĞÊ±¼ä¼Ó1
 317   1      
 318   1              EA = 1; //ÈÎÎñÇĞ»»Íê³É£¬ÖØĞÂ¿ªÆôÖĞ¶Ï
 319   1      }
 320          
 321          /* ÏµÍ³ÈÎÎñÑÓÊ± */
 322          void task_delay(unsigned char delay)
 323          {
 324   1              task_pcb_buf[current_id].delay = delay;
 325   1              TF1 = 1;        //ÉèÖÃÍêÖ®ºóÁ¢Âí½øÈëÖĞ¶Ï£¬·ñÔòÈÎÎñ»á¼ÌĞøÖ´ĞĞµ½ÏÂÒ»¸öÖĞ¶Ï×ÔĞĞµ½À´
 326   1      }
 327          
 328          /* ÏµÍ³ĞÂÖÜÆÚ¿ªÊ¼ÅĞ¶Ï */
 329          unsigned char get_task_newcircle_flag(void)
 330          {
 331   1              if(task_pcb_buf[current_id].new_circle == 1)    //ÊÇĞÂÖÜÆÚµÄ¿ªÊ¼
 332   1              {
 333   2                      task_pcb_buf[current_id].new_circle = 0;        //Çå³ı¿ªÊ¼±êÖ¾²¢·µ»Ø1
 334   2                      return 1;
 335   2              }
 336   1              return 0;
 337   1      }
 338          
 339          /* ´òÓ¡»ú×ÊÔ´µÄÊ¹ÓÃ */
 340          
 341          /* ¶ÑÕ»µÄ²âÊÔ */
 342          void sp_test(void)
 343          {
 344   1              SP = task_sp;
 345   1      
 346   1      }
 347          //      #pragma asm
 348          //              PUSH DPL
 349          //              PUSH DPH
 350          //      #pragma endasm
 351          
 352          //      void push_ptr(void)
 353          //{
 354          //      #pragma asm
 355          //              PUSH ACC
 356          //              PUSH B
 357          //              PUSH DPL
 358          //              PUSH DPH
 359          //              PUSH PSW
 360          //              PUSH 0
C51 COMPILER V9.02   CORE                                                                  03/26/2016 11:01:22 PAGE 7   

 361          //              PUSH 1
 362          //              PUSH 2
 363          //              PUSH 3
 364          //              PUSH 4
 365          //              PUSH 5
 366          //              PUSH 6
 367          //              PUSH 7
 368          //      #pragma endasm
 369          //}
 370          //
 371          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1512    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    545       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      15
   IDATA SIZE       =    150    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
