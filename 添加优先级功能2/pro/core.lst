C51 COMPILER V9.02   CORE                                                                  03/07/2016 13:56:03 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE CORE
OBJECT MODULE PLACED IN .\core.obj
COMPILER INVOKED BY: D:\msprograms\keil4\C51\BIN\C51.EXE ..\src\core.c OPTIMIZE(2,SPEED) BROWSE INCDIR(../head) DEBUG OB
                    -JECTEXTEND PRINT(.\core.lst) OBJECT(.\core.obj)

line level    source

   1          #include "core.h"
   2          
   3          /* 申请任务控制模块结构体数组，存储所有任务的控制结构体 */
   4          xdata struct task_pcb task_pcb_buf[TASK_MAX];
   5          /* 任务堆栈数组 */
   6          static unsigned char idata task_sp[TASK_MAX][SP_DEEP];
   7          /* 正在运行任务的id，初始化为0，默认最开始运行0号任务 */
   8          xdata unsigned char current_id = 0;
   9          /* 任务运行标志，值反映了有多少任务正在运行 */
  10          xdata unsigned long task_run_flag = 0;
  11          /* 统计进入临界栈的次数 */
  12          xdata unsigned int critical_counter = 0;
  13          /* 从开机到现在任务运行时间，单位10ms */
  14          xdata unsigned long task_runtime = 0;
  15          /* 串口接收数据缓冲区，长度为256个字节 */
  16          xdata unsigned char reve_buff[256];
  17          /* 设置系统运行标志，1为正在运行，0为未开始运行。初始化为0 */
  18          bit task_start_flag = 0;
  19          
  20          //void pop_ptr(void)
  21          //{
  22          //      #pragma asm
  23          //              POP 7
  24          //              POP 6
  25          //              POP 5
  26          //              POP 4
  27          //              POP 3
  28          //              POP 2
  29          //              POP 1
  30          //              POP 0
  31          //              POP PSW
  32          //              POP DPH
  33          //              POP DPL
  34          //              POP B
  35          //              POP ACC
  36          //      #pragma endasm
  37          //}
  38          
  39          /* 系统延时,单位ms */
  40          void OS_delay(unsigned int ms)
  41          {
  42   1              ms = ms / 10;   
  43   1              task_delay(ms);
  44   1      
  45   1              while(task_pcb_buf[current_id].delay);
  46   1      }
  47          
  48          /* 系统开机初始化 */
  49          void OS_init(void)
  50          {
  51   1              current_id = 0;                 //当前运行任务号为0
  52   1              task_run_flag = 0;              //当前无任务运行
  53   1              task_runtime = 0;               //当前运行时间为0
  54   1              task_start_flag = 0;    //系统未开始运行        
C51 COMPILER V9.02   CORE                                                                  03/07/2016 13:56:03 PAGE 2   

  55   1      }
  56          
  57          /* 系统开始任务调度 */
  58          void OS_start(void)
  59          {
  60   1              task_pcb_buf[current_id].sp -= NUM_PTR_NOPC;
  61   1      
  62   1              SP = task_pcb_buf[current_id].sp;
  63   1              TR1 = 1;                                                                                  //开始计时
  64   1              ET1 = 1;                                                                                  //使能定时器1
  65   1              EA  = 1;                                                                                  //开全局中断
  66   1      }
  67          
  68          /* 任务切换，用在定时器里面进行任务的切换 */
  69          void task_switch(void)
  70          {
  71   1              EA= 0;  //任务切换的时候不允许被中断
  72   1              /* 保存寄存器值，寄存器值入栈 */
  73   1      //      push_ptr();
  74   1              /* 把转换之前任务的栈指针保存在数组里面 */
  75   1              task_pcb_buf[current_id].sp = SP;
  76   1      //      if(tasks_list
  77   1      
  78   1              /* 寄存器值出栈，恢复寄存器值 */
  79   1      //      pop_ptr();
  80   1              EA = 1; //任务切换完成，重新开启中断
  81   1      }
  82          
  83          /* 创建任务 
  84           * priority 任务优先级
  85           * task_address 任务地址
  86           * task_msg 任务消息指针
  87           */
  88          unsigned char task_create(unsigned char priority, unsigned int task_address, unsigned char xdata *task_msg
             -)
  89          {
  90   1              static unsigned char i = 0;
  91   1              static unsigned char stack_deep = 0;
  92   1              static unsigned char stack_p;
  93   1      
  94   1              for(i = 0; i < TASK_MAX; i ++)
  95   1              {
  96   2                      if(task_run_flag & (1 << i))
  97   2                              ;
  98   2                      else
  99   2                      {
 100   3                              stack_p = (unsigned char)task_sp[i];    //把堆栈指针的地址赋值堆栈地址暂存区
 101   3                              /* 初始化清空堆栈区 */
 102   3                              for(stack_deep = 0; stack_deep < SP_DEEP; stack_deep ++)
 103   3                                      ((unsigned char idata *)stack_p)[stack_deep] = 0;
 104   3                              
 105   3                              task_pcb_buf[i].sp = stack_p;   //把堆栈指针赋值给任务结构体
 106   3                              ((unsigned char idata *)stack_p)[0] = task_address % 256;         //把任务地址低8位入栈
 107   3                              task_pcb_buf[i].sp ++;
 108   3                              ((unsigned char idata *)stack_p)[1] = task_address >> 8;          //把任务地址高8位入栈
 109   3                              
 110   3                              task_pcb_buf[i].sp += NUM_PTR_NOPC;             //将任务堆栈指针值设为任务切换时的状态
 111   3                              task_pcb_buf[i].priority = priority;    //设置任务的优先级
 112   3                              task_pcb_buf[i].msg              = task_msg;    //设置任务的消息指针
 113   3                              
 114   3                              task_run_flag |= (1 << i);              //把此位设置为有任务
 115   3                              
C51 COMPILER V9.02   CORE                                                                  03/07/2016 13:56:03 PAGE 3   

 116   3                              return 0;       //任务创建成功，返回
 117   3                      }
 118   2              }
 119   1      
 120   1              return 1;                       //资源不足，无法继续创建任务，返回1
 121   1      }
 122          
 123          
 124          /* 中断服务函数，用定时器1进行任务调度 */
 125          void timer1_task_switch(void) interrupt 3
 126          {
 127   1              unsigned char temp = 0;
 128   1              
 129   1              EA = 0; //任务切换的时候要关闭中断
 130   1      
 131   1      //      if(!task_start_flag)    //第一次进入中断
 132   1      //      {
 133   1      //              SP = SP - NUM_PTR_NOPC; //此时指针指向调用此中断时候压入的PC低地址
 134   1      //              for(temp = 1; temp < NUM_PTR_NOPC + 1; temp ++)
 135   1      //              {
 136   1      //                      ((unsigned char idata *)SP)[temp] = ((unsigned char idata *)SP)[temp + 2];      //将除了PC之外的寄存器值往
             -下平移两位
 137   1      //              }
 138   1      //              SP = SP + NUM_PTR_NOPC;
 139   1      //              task_start_flag = 1; //设置系统运行标志，此时为已经运行
 140   1      //      }
 141   1      
 142   1              /* 保存寄存器值，寄存器值入栈 */
 143   1      //      push_ptr();      /* 在现有编译环境下寄存器已经由系统自动保存了 */
 144   1              
 145   1              TF1 = 0;        //清除中断标志
 146   1              
 147   1              /* 把转换之前任务的栈指针保存在其任务结构体里面 */
 148   1              task_pcb_buf[current_id].sp = SP;
 149   1      #if 0
                      /* 第一版，任务轮流被调用，查找本次任务之后的任务，有的话直接跳到 T2_switch_exit 处执行*/
                      for(temp = current_id + 1; temp < TASK_MAX; temp ++)
                      {
                              if(task_run_flag & (1 << temp))
                              {
                                      current_id = temp;
                                      goto T2_switch_exit;                    
                              }
                      }
              
                      /* 没有找到正在运行任务之后的任务，返回前面进行查找 */
                      for(temp = 0; temp < current_id + 1; temp ++)
                      {
                              if(task_run_flag & (1 << temp))
                              {
                                      current_id = temp;
                                      goto T2_switch_exit;    
                              }
                              else
                                      goto T2_switch_exit;
                      }
              #endif
 172   1      
 173   1              current_id = 0;
 174   1      
 175   1              for(temp = 1; temp < TASK_MAX; temp ++)
 176   1              {
C51 COMPILER V9.02   CORE                                                                  03/07/2016 13:56:03 PAGE 4   

 177   2                      if(task_run_flag & (1 << temp))
 178   2                      {
 179   3                              if(task_pcb_buf[temp].priority < task_pcb_buf[current_id].priority)
 180   3                              {
 181   4                                      if(task_pcb_buf[temp].delay != 0)
 182   4                                      {
 183   5                                              task_pcb_buf[temp].delay --;                    
 184   5                                      }
 185   4                                      else if(task_pcb_buf[temp].suspend == 1)
 186   4                                              continue;
 187   4                                      else
 188   4                                              current_id = temp;              
 189   4                              }
 190   3                      }
 191   2              }
 192   1      
 193   1      T2_switch_exit:
 194   1              SP = task_pcb_buf[current_id].sp;       //把要运行的任务SP地址传入SP寄存器
 195   1      
 196   1              task_runtime ++;        //系统运行时间加1
 197   1      
 198   1              EA = 1; //任务切换完成，重新开启中断
 199   1      }
*** WARNING C280 IN LINE 193 OF ..\SRC\CORE.C: 'T2_switch_exit': unreferenced label
 200          
 201          /* 系统任务延时 */
 202          void task_delay(unsigned char delay)
 203          {
 204   1              task_pcb_buf[current_id].delay = delay;
 205   1      }
 206          
 207          /* 打印机资源的使用 */
 208          
 209          /* 堆栈的测试 */
 210          void sp_test(void)
 211          {
 212   1              SP = task_sp;
 213   1      
 214   1      }
 215          //      #pragma asm
 216          //              PUSH DPL
 217          //              PUSH DPH
 218          //      #pragma endasm
 219          
 220          //      void push_ptr(void)
 221          //{
 222          //      #pragma asm
 223          //              PUSH ACC
 224          //              PUSH B
 225          //              PUSH DPL
 226          //              PUSH DPH
 227          //              PUSH PSW
 228          //              PUSH 0
 229          //              PUSH 1
 230          //              PUSH 2
 231          //              PUSH 3
 232          //              PUSH 4
 233          //              PUSH 5
 234          //              PUSH 6
 235          //              PUSH 7
 236          //      #pragma endasm
 237          //}
C51 COMPILER V9.02   CORE                                                                  03/07/2016 13:56:03 PAGE 5   

 238          //
 239          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    875    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    312    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       9
   IDATA SIZE       =    150    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
